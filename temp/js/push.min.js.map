{"version":3,"file":"push.min.js","sources":["../src/push/Messages.js","../src/push/Permission.js","../src/push/Util.js","../src/agents/AbstractAgent.js","../src/agents/DesktopAgent.js","../src/agents/MobileChromeAgent.js","../src/agents/MobileFirefoxAgent.js","../src/agents/MSAgent.js","../src/agents/WebKitAgent.js","../src/index.js","../src/push/Push.js"],"sourcesContent":["// @flow\nconst errorPrefix = 'PushError:';\n\nexport default {\n errors: {\n incompatible: `${errorPrefix} Push.js is incompatible with browser.`,\n invalid_plugin: `${errorPrefix} plugin class missing from plugin manifest (invalid plugin). Please check the documentation.`,\n invalid_title: `${errorPrefix} title of notification must be a string`,\n permission_denied: `${errorPrefix} permission request declined`,\n sw_notification_error: `${errorPrefix} could not show a ServiceWorker notification due to the following reason: `,\n sw_registration_error: `${errorPrefix} could not register the ServiceWorker due to the following reason: `,\n unknown_interface: `${errorPrefix} unable to create notification: unknown interface`\n }\n};\n","// @flow\nimport type { Global } from 'types';\n\nexport default class Permission {\n // Private members\n _permissions: string[];\n _win: Global;\n\n // Public members\n GRANTED: string;\n DEFAULT: string;\n DENIED: string;\n\n constructor(win: Global) {\n this._win = win;\n this.GRANTED = 'granted';\n this.DEFAULT = 'default';\n this.DENIED = 'denied';\n this._permissions = [this.GRANTED, this.DEFAULT, this.DENIED];\n }\n\n /**\n * Requests permission for desktop notifications\n * @param {Function} onGranted - Function to execute once permission is granted\n * @param {Function} onDenied - Function to execute once permission is denied\n * @return {void, Promise}\n */\n request(onGranted: () => void, onDenied: () => void) {\n return arguments.length > 0\n ? this._requestWithCallback(...arguments)\n : this._requestAsPromise();\n }\n\n /**\n * Old permissions implementation deprecated in favor of a promise based one\n * @deprecated Since V1.0.4\n * @param {Function} onGranted - Function to execute once permission is granted\n * @param {Function} onDenied - Function to execute once permission is denied\n * @return {void}\n */\n _requestWithCallback(onGranted: () => void, onDenied: () => void) {\n const existing = this.get();\n\n var resolve = (result = this._win.Notification.permission) => {\n if (typeof result === 'undefined' && this._win.webkitNotifications)\n result = this._win.webkitNotifications.checkPermission();\n if (result === this.GRANTED || result === 0) {\n if (onGranted) onGranted();\n } else if (onDenied) onDenied();\n };\n\n /* Permissions already set */\n if (existing !== this.DEFAULT) {\n resolve(existing);\n } else if (\n this._win.webkitNotifications &&\n this._win.webkitNotifications.checkPermission\n ) {\n /* Safari 6+, Legacy webkit browsers */\n this._win.webkitNotifications.requestPermission(resolve);\n } else if (\n this._win.Notification &&\n this._win.Notification.requestPermission\n ) {\n /* Chrome 23+ */\n this._win.Notification\n .requestPermission()\n .then(resolve)\n .catch(function() {\n if (onDenied) onDenied();\n });\n } else if (onGranted) {\n /* Let the user continue by default */\n onGranted();\n }\n }\n\n /**\n * Requests permission for desktop notifications in a promise based way\n * @return {Promise}\n */\n _requestAsPromise(): Promise<void> {\n const existing = this.get();\n\n let isGranted = result => result === this.GRANTED || result === 0;\n\n /* Permissions already set */\n var hasPermissions = existing !== this.DEFAULT;\n\n /* Safari 6+, Chrome 23+ */\n var isModernAPI =\n this._win.Notification && this._win.Notification.requestPermission;\n\n /* Legacy webkit browsers */\n var isWebkitAPI =\n this._win.webkitNotifications &&\n this._win.webkitNotifications.checkPermission;\n\n return new Promise((resolvePromise, rejectPromise) => {\n var resolver = result =>\n isGranted(result) ? resolvePromise() : rejectPromise();\n\n if (hasPermissions) {\n resolver(existing);\n } else if (isWebkitAPI) {\n this._win.webkitNotifications.requestPermission(result => {\n resolver(result);\n });\n } else if (isModernAPI) {\n this._win.Notification\n .requestPermission()\n .then(result => {\n resolver(result);\n })\n .catch(rejectPromise);\n } else resolvePromise();\n });\n }\n\n /**\n * Returns whether Push has been granted permission to run\n * @return {Boolean}\n */\n has() {\n return this.get() === this.GRANTED;\n }\n\n /**\n * Gets the permission level\n * @return {Permission} The permission level\n */\n get() {\n let permission;\n\n /* Safari 6+, Chrome 23+ */\n if (this._win.Notification && this._win.Notification.permission)\n permission = this._win.Notification.permission;\n else if (\n this._win.webkitNotifications &&\n this._win.webkitNotifications.checkPermission\n )\n /* Legacy webkit browsers */\n permission = this._permissions[\n this._win.webkitNotifications.checkPermission()\n ];\n else if (navigator.mozNotification)\n /* Firefox Mobile */\n permission = this.GRANTED;\n else if (this._win.external && this._win.external.msIsSiteMode)\n /* IE9+ */\n permission = this._win.external.msIsSiteMode()\n ? this.GRANTED\n : this.DEFAULT;\n else permission = this.GRANTED;\n\n return permission;\n }\n}\n","// @flow\nexport default class Util {\n static isUndefined(obj) {\n return obj === undefined;\n }\n\n static isString(obj) {\n return typeof obj === 'string';\n }\n\n static isFunction(obj) {\n return obj && {}.toString.call(obj) === '[object Function]';\n }\n\n static isObject(obj) {\n return typeof obj === 'object';\n }\n\n static objectMerge(target, source) {\n for (var key in source) {\n if (\n target.hasOwnProperty(key) &&\n this.isObject(target[key]) &&\n this.isObject(source[key])\n ) {\n this.objectMerge(target[key], source[key]);\n } else {\n target[key] = source[key];\n }\n }\n }\n}\n","// @flow\nimport type { Global } from 'types';\n\nexport default class AbstractAgent {\n _win: Global;\n\n constructor(win: Global) {\n this._win = win;\n }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, GenericNotification, Global } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class DesktopAgent extends AbstractAgent {\n _win: Global;\n\n /**\n * Returns a boolean denoting support\n * @returns {Boolean} boolean denoting whether webkit notifications are supported\n */\n isSupported() {\n return this._win.Notification !== undefined;\n }\n\n /**\n * Creates a new notification\n * @param title - notification title\n * @param options - notification options array\n * @returns {Notification}\n */\n create(title: string, options: PushOptions) {\n return new this._win.Notification(title, {\n icon:\n Util.isString(options.icon) || Util.isUndefined(options.icon)\n ? options.icon\n : options.icon.x32,\n body: options.body,\n tag: options.tag,\n requireInteraction: options.requireInteraction\n });\n }\n\n /**\n * Close a given notification\n * @param notification - notification to close\n */\n close(notification: GenericNotification) {\n notification.close();\n }\n}\n","// @flow\nimport { Util, Messages } from 'push';\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileChromeAgent extends AbstractAgent {\n _win: Global;\n\n /**\n * Returns a boolean denoting support\n * @returns {Boolean} boolean denoting whether webkit notifications are supported\n */\n isSupported() {\n return (\n this._win.navigator !== undefined &&\n this._win.navigator.serviceWorker !== undefined\n );\n }\n\n /**\n * Returns the function body as a string\n * @param func\n */\n getFunctionBody(func: () => void) {\n const str = func.toString().match(/function[^{]+{([\\s\\S]*)}$/);\n return typeof str !== 'undefined' && str !== null && str.length > 1\n ? str[1]\n : null;\n }\n\n /**\n * Creates a new notification\n * @param id ID of notification\n * @param title Title of notification\n * @param options Options object\n * @param serviceWorker ServiceWorker path\n * @param callback Callback function\n */\n create(\n id: number,\n title: string,\n options: PushOptions,\n serviceWorker: string,\n callback: (GenericNotification[]) => void\n ) {\n /* Register ServiceWorker */\n this._win.navigator.serviceWorker.register(serviceWorker);\n\n this._win.navigator.serviceWorker.ready\n .then(registration => {\n /* Local data the service worker will use */\n let localData = {\n id: id,\n link: options.link,\n origin: document.location.href,\n onClick: Util.isFunction(options.onClick)\n ? this.getFunctionBody(options.onClick)\n : '',\n onClose: Util.isFunction(options.onClose)\n ? this.getFunctionBody(options.onClose)\n : ''\n };\n\n /* Merge the local data with user-provided data */\n if (options.data !== undefined && options.data !== null)\n localData = Object.assign(localData, options.data);\n\n /* Show the notification */\n registration\n .showNotification(title, {\n icon: options.icon,\n body: options.body,\n vibrate: options.vibrate,\n tag: options.tag,\n data: localData,\n requireInteraction: options.requireInteraction,\n silent: options.silent\n })\n .then(() => {\n registration.getNotifications().then(notifications => {\n /* Send an empty message so the ServiceWorker knows who the client is */\n registration.active.postMessage('');\n\n /* Trigger callback */\n callback(notifications);\n });\n })\n .catch(function(error) {\n throw new Error(\n Messages.errors.sw_notification_error +\n error.message\n );\n });\n })\n .catch(function(error) {\n throw new Error(\n Messages.errors.sw_registration_error + error.message\n );\n });\n }\n\n /**\n * Close all notification\n */\n close() {\n // Can't do this with service workers\n }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileFirefoxAgent extends AbstractAgent {\n _win: Global;\n\n /**\n * Returns a boolean denoting support\n * @returns {Boolean} boolean denoting whether webkit notifications are supported\n */\n isSupported() {\n return this._win.navigator.mozNotification !== undefined;\n }\n\n /**\n * Creates a new notification\n * @param title - notification title\n * @param options - notification options array\n * @returns {Notification}\n */\n create(title: string, options: PushOptions) {\n let notification = this._win.navigator.mozNotification.createNotification(\n title,\n options.body,\n options.icon\n );\n\n notification.show();\n\n return notification;\n }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, Global } from 'types';\n\n/**\n * Notification agent for IE9\n */\nexport default class MSAgent extends AbstractAgent {\n _win: Global;\n\n /**\n * Returns a boolean denoting support\n * @returns {Boolean} boolean denoting whether webkit notifications are supported\n */\n isSupported() {\n return (\n this._win.external !== undefined &&\n this._win.external.msIsSiteMode !== undefined\n );\n }\n\n /**\n * Creates a new notification\n * @param title - notification title\n * @param options - notification options array\n * @returns {Notification}\n */\n create(title: string, options: PushOptions) {\n /* Clear any previous notifications */\n this._win.external.msSiteModeClearIconOverlay();\n\n this._win.external.msSiteModeSetIconOverlay(\n Util.isString(options.icon) || Util.isUndefined(options.icon)\n ? options.icon\n : options.icon.x16,\n title\n );\n\n this._win.external.msSiteModeActivate();\n\n return null;\n }\n\n /**\n * Close a given notification\n * @param notification - notification to close\n */\n close() {\n this._win.external.msSiteModeClearIconOverlay();\n }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for old Chrome versions (and some) Firefox\n */\nexport default class WebKitAgent extends AbstractAgent {\n _win: Global;\n\n /**\n * Returns a boolean denoting support\n * @returns {Boolean} boolean denoting whether webkit notifications are supported\n */\n isSupported() {\n return this._win.webkitNotifications !== undefined;\n }\n\n /**\n * Creates a new notification\n * @param title - notification title\n * @param options - notification options array\n * @returns {Notification}\n */\n create(title: string, options: PushOptions) {\n let notification = this._win.webkitNotifications.createNotification(\n options.icon,\n title,\n options.body\n );\n\n notification.show();\n\n return notification;\n }\n\n /**\n * Close a given notification\n * @param notification - notification to close\n */\n close(notification: GenericNotification) {\n notification.cancel();\n }\n}\n","// @flow\nimport { Push } from 'push';\n\nexport default new Push(typeof window !== 'undefined' ? window : global);\n","// @flow\nimport { Messages, Permission, Util } from 'push';\nimport type { PluginManifest, GenericNotification, PushOptions } from 'types';\n\n/* Import notification agents */\nimport {\n DesktopAgent,\n MobileChromeAgent,\n MobileFirefoxAgent,\n MSAgent,\n WebKitAgent\n} from 'agents';\n\nexport default class Push {\n // Private members\n _agents: {\n desktop: DesktopAgent,\n chrome: MobileChromeAgent,\n firefox: MobileFirefoxAgent,\n ms: MSAgent,\n webkit: WebKitAgent\n };\n _configuration: {\n serviceWorker: string,\n fallback: ({}) => void\n };\n _currentId: number;\n _notifications: {};\n _win: {};\n\n // Public members\n Permission: Permission;\n\n constructor(win: {}) {\n /* Private variables */\n\n /* ID to use for new notifications */\n this._currentId = 0;\n\n /* Map of open notifications */\n this._notifications = {};\n\n /* Window object */\n this._win = win;\n\n /* Public variables */\n this.Permission = new Permission(win);\n\n /* Agents */\n this._agents = {\n desktop: new DesktopAgent(win),\n chrome: new MobileChromeAgent(win),\n firefox: new MobileFirefoxAgent(win),\n ms: new MSAgent(win),\n webkit: new WebKitAgent(win)\n };\n\n this._configuration = {\n serviceWorker: '/serviceWorker.min.js',\n fallback: function(payload) {}\n };\n }\n\n /**\n * Closes a notification\n * @param id ID of notification\n * @returns {boolean} denotes whether the operation was successful\n * @private\n */\n _closeNotification(id: number | string) {\n let success = true;\n const notification = this._notifications[id];\n\n if (notification !== undefined) {\n success = this._removeNotification(id);\n\n /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n if (this._agents.desktop.isSupported())\n this._agents.desktop.close(notification);\n else if (this._agents.webkit.isSupported())\n /* Legacy WebKit browsers */\n this._agents.webkit.close(notification);\n else if (this._agents.ms.isSupported())\n /* IE9 */\n this._agents.ms.close();\n else {\n success = false;\n throw new Error(Messages.errors.unknown_interface);\n }\n\n return success;\n }\n\n return false;\n }\n\n /**\n * Adds a notification to the global dictionary of notifications\n * @param {Notification} notification\n * @return {Integer} Dictionary key of the notification\n * @private\n */\n _addNotification(notification: GenericNotification) {\n const id = this._currentId;\n this._notifications[id] = notification;\n this._currentId++;\n return id;\n }\n\n /**\n * Removes a notification with the given ID\n * @param {Integer} id - Dictionary key/ID of the notification to remove\n * @return {Boolean} boolean denoting success\n * @private\n */\n _removeNotification(id: number | string) {\n let success = false;\n\n if (this._notifications.hasOwnProperty(id)) {\n /* We're successful if we omit the given ID from the new array */\n delete this._notifications[id];\n success = true;\n }\n\n return success;\n }\n\n /**\n * Creates the wrapper for a given notification\n *\n * @param {Integer} id - Dictionary key/ID of the notification\n * @param {Map} options - Options used to create the notification\n * @returns {Map} wrapper hashmap object\n * @private\n */\n _prepareNotification(id: number, options: PushOptions) {\n let wrapper;\n\n /* Wrapper used to get/close notification later on */\n wrapper = {\n get: () => {\n return this._notifications[id];\n },\n\n close: () => {\n this._closeNotification(id);\n }\n };\n\n /* Autoclose timeout */\n if (options.timeout) {\n setTimeout(() => {\n wrapper.close();\n }, options.timeout);\n }\n\n return wrapper;\n }\n\n /**\n * Find the most recent notification from a ServiceWorker and add it to the global array\n * @param notifications\n * @private\n */\n _serviceWorkerCallback(\n notifications: GenericNotification[],\n options: PushOptions,\n resolve: ({} | null) => void\n ) {\n let id = this._addNotification(notifications[notifications.length - 1]);\n\n /* Listen for close requests from the ServiceWorker */\n if (navigator && navigator.serviceWorker) {\n navigator.serviceWorker.addEventListener('message', event => {\n const data = JSON.parse(event.data);\n\n if (data.action === 'close' && Number.isInteger(data.id))\n this._removeNotification(data.id);\n });\n\n resolve(this._prepareNotification(id, options));\n }\n\n resolve(null);\n }\n\n /**\n * Callback function for the 'create' method\n * @return {void}\n * @private\n */\n _createCallback(\n title: string,\n options: PushOptions,\n resolve: ({} | null) => void\n ) {\n let notification = null;\n let onClose;\n\n /* Set empty settings if none are specified */\n options = options || {};\n\n /* onClose event handler */\n onClose = id => {\n /* A bit redundant, but covers the cases when close() isn't explicitly called */\n this._removeNotification(id);\n if (Util.isFunction(options.onClose)) {\n options.onClose.call(this, notification);\n }\n };\n\n /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n if (this._agents.desktop.isSupported()) {\n try {\n /* Create a notification using the API if possible */\n notification = this._agents.desktop.create(title, options);\n } catch (e) {\n const id = this._currentId;\n const sw = this.config().serviceWorker;\n const cb = notifications =>\n this._serviceWorkerCallback(\n notifications,\n options,\n resolve\n );\n /* Create a Chrome ServiceWorker notification if it isn't supported */\n if (this._agents.chrome.isSupported()) {\n this._agents.chrome.create(id, title, options, sw, cb);\n }\n }\n /* Legacy WebKit browsers */\n } else if (this._agents.webkit.isSupported())\n notification = this._agents.webkit.create(title, options);\n else if (this._agents.firefox.isSupported())\n /* Firefox Mobile */\n this._agents.firefox.create(title, options);\n else if (this._agents.ms.isSupported())\n /* IE9 */\n notification = this._agents.ms.create(title, options);\n else {\n /* Default fallback */\n options.title = title;\n this.config().fallback(options);\n }\n\n if (notification !== null) {\n const id = this._addNotification(notification);\n const wrapper = this._prepareNotification(id, options);\n\n /* Notification callbacks */\n if (Util.isFunction(options.onShow))\n notification.addEventListener('show', options.onShow);\n\n if (Util.isFunction(options.onError))\n notification.addEventListener('error', options.onError);\n\n if (Util.isFunction(options.onClick))\n notification.addEventListener('click', options.onClick);\n\n notification.addEventListener('close', () => {\n onClose(id);\n });\n\n notification.addEventListener('cancel', () => {\n onClose(id);\n });\n\n /* Return the wrapper so the user can call close() */\n resolve(wrapper);\n }\n\n /* By default, pass an empty wrapper */\n resolve(null);\n }\n\n /**\n * Creates and displays a new notification\n * @param {Array} options\n * @return {Promise}\n */\n create(title: string, options: {}): Promise<void> {\n let promiseCallback;\n\n /* Fail if no or an invalid title is provided */\n if (!Util.isString(title)) {\n throw new Error(Messages.errors.invalid_title);\n }\n\n /* Request permission if it isn't granted */\n if (!this.Permission.has()) {\n promiseCallback = (resolve: () => void, reject: string => void) => {\n this.Permission\n .request()\n .then(() => {\n this._createCallback(title, options, resolve);\n })\n .catch(() => {\n reject(Messages.errors.permission_denied);\n });\n };\n } else {\n promiseCallback = (resolve: () => void, reject: string => void) => {\n try {\n this._createCallback(title, options, resolve);\n } catch (e) {\n reject(e);\n }\n };\n }\n\n return new Promise(promiseCallback);\n }\n\n /**\n * Returns the notification count\n * @return {Integer} The notification count\n */\n count() {\n let count = 0;\n let key;\n\n for (key in this._notifications)\n if (this._notifications.hasOwnProperty(key)) count++;\n\n return count;\n }\n\n /**\n * Closes a notification with the given tag\n * @param {String} tag - Tag of the notification to close\n * @return {Boolean} boolean denoting success\n */\n close(tag: string) {\n let key, notification;\n\n for (key in this._notifications) {\n if (this._notifications.hasOwnProperty(key)) {\n notification = this._notifications[key];\n\n /* Run only if the tags match */\n if (notification.tag === tag) {\n /* Call the notification's close() method */\n return this._closeNotification(key);\n }\n }\n }\n }\n\n /**\n * Clears all notifications\n * @return {Boolean} boolean denoting whether the clear was successful in closing all notifications\n */\n clear() {\n let key,\n success = true;\n\n for (key in this._notifications)\n if (this._notifications.hasOwnProperty(key))\n success = success && this._closeNotification(key);\n\n return success;\n }\n\n /**\n * Denotes whether Push is supported in the current browser\n * @returns {boolean}\n */\n supported() {\n let supported = false;\n\n for (var agent in this._agents)\n if (this._agents.hasOwnProperty(agent))\n supported = supported || this._agents[agent].isSupported();\n\n return supported;\n }\n\n /**\n * Modifies settings or returns all settings if no parameter passed\n * @param settings\n */\n config(settings?: {}) {\n if (\n typeof settings !== 'undefined' ||\n (settings !== null && Util.isObject(settings))\n )\n Util.objectMerge(this._configuration, settings);\n\n return this._configuration;\n }\n\n /**\n * Copies the functions from a plugin to the main library\n * @param plugin\n */\n extend(manifest: PluginManifest) {\n var plugin,\n Plugin,\n hasProp = {}.hasOwnProperty;\n\n if (!hasProp.call(manifest, 'plugin')) {\n throw new Error(Messages.errors.invalid_plugin);\n } else {\n if (\n hasProp.call(manifest, 'config') &&\n Util.isObject(manifest.config) &&\n manifest.config !== null\n ) {\n this.config(manifest.config);\n }\n\n Plugin = manifest.plugin;\n plugin = new Plugin(this.config());\n\n for (var member in plugin) {\n if (\n hasProp.call(plugin, member) &&\n Util.isFunction(plugin[member])\n )\n // $FlowFixMe\n this[member] = plugin[member];\n }\n }\n }\n}\n"],"names":["errorPrefix","Permission","win","_win","GRANTED","DEFAULT","DENIED","_permissions","this","onGranted","onDenied","arguments","length","_requestWithCallback","_requestAsPromise","existing","get","resolve","result","_this","Notification","permission","webkitNotifications","checkPermission","requestPermission","then","catch","isGranted","_this2","hasPermissions","isModernAPI","isWebkitAPI","Promise","resolvePromise","rejectPromise","resolver","navigator","mozNotification","external","msIsSiteMode","Util","obj","undefined","toString","call","target","source","key","hasOwnProperty","isObject","objectMerge","AbstractAgent","DesktopAgent","title","options","isString","icon","isUndefined","x32","body","tag","requireInteraction","notification","close","MobileChromeAgent","serviceWorker","func","str","match","id","callback","register","ready","localData","link","document","location","href","isFunction","onClick","getFunctionBody","onClose","data","Object","assign","showNotification","vibrate","silent","getNotifications","active","postMessage","notifications","error","Error","Messages","errors","sw_notification_error","message","sw_registration_error","MobileFirefoxAgent","createNotification","show","MSAgent","msSiteModeClearIconOverlay","msSiteModeSetIconOverlay","x16","msSiteModeActivate","WebKitAgent","cancel","_currentId","_notifications","_agents","_configuration","payload","success","_removeNotification","desktop","isSupported","webkit","ms","unknown_interface","wrapper","_closeNotification","timeout","_addNotification","addEventListener","JSON","parse","event","action","Number","isInteger","_prepareNotification","create","e","sw","config","cb","_this3","_serviceWorkerCallback","chrome","firefox","fallback","onShow","onError","promiseCallback","invalid_title","has","reject","_createCallback","request","permission_denied","count","supported","agent","settings","manifest","plugin","hasProp","invalid_plugin","member","window","global"],"mappings":"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"}